# -*- coding: utf-8 -*-
"""Weather Predicition

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aiu_iWl3QCR-_Je-oVHxaP2bKLUFzm3p
"""

# Commented out IPython magic to ensure Python compatibility.
from google.colab import drive
drive.mount('/content/drive')
# %ls
# %cd drive/
# %ls
# %cd My\ Drive
# %ls
# %cd MLDA/
# %ls

# Import

import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

from sklearn.preprocessing import MinMaxScaler, LabelEncoder
from sklearn.model_selection import train_test_split

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import SimpleRNN, Dense
from tensorflow.keras.layers import LSTM, Dense, Dropout, Bidirectional

df = pd.read_csv('weather_prediction_dataset.csv')
print(df.shape)

df.head(5)

df.tail(5)

print(df.describe())

df.count()

print(df.isnull().sum())

duplicate_rows_df = df[df.duplicated()]
print("number of duplicate rows: ", duplicate_rows_df.shape)

print(df.dtypes)

# Filter columns for Heathrow
heathrow_columns = [col for col in df.columns if 'HEATHROW' in col]
heathrow_columns.insert(0, 'DATE')
df_heathrow = df[heathrow_columns]

print(df_heathrow.head())

plt.figure(figsize=(20,10))
corl= df_heathrow.corr(numeric_only = True)
sns.heatmap(corl,cmap="coolwarm",annot=True)
print(corl)

df['DATE'] = pd.to_datetime(df['DATE'], format='%Y%m%d')

weather = ['HEATHROW_cloud_cover',  'HEATHROW_humidity', 'HEATHROW_sunshine', 'HEATHROW_global_radiation']
target = ['HEATHROW_temp_mean']

scaler_features = MinMaxScaler()
scaler_target = MinMaxScaler()

df[weather] = scaler_features.fit_transform(df[weather])
df[target] = scaler_target.fit_transform(df[target])

import numpy as np
from sklearn.preprocessing import MinMaxScaler

def create_sequences(data, time_steps, target_col_idx):
    X, y = [], []
    for i in range(len(data) - time_steps):
        X.append(data[i:i + time_steps, :])
        y.append(data[i + time_steps, target_col_idx])
    return np.array(X), np.array(y)

weather = ['HEATHROW_cloud_cover', 'HEATHROW_humidity', 'HEATHROW_sunshine', 'HEATHROW_global_radiation']
target = ['HEATHROW_temp_mean']

scaler = MinMaxScaler()
data_scaled = scaler.fit_transform(df[weather + target].values)

time_steps = 10
target_col_idx = len(weather)
X, y = create_sequences(data_scaled, time_steps, target_col_idx)

train_size = int(len(X) * 0.8)
X_train, X_test = X[:train_size], X[train_size:]
y_train, y_test = y[:train_size], y[train_size:]

num_features = X_train.shape[2]
X_train = X_train.reshape((X_train.shape[0], X_train.shape[1], num_features))
X_test = X_test.reshape((X_test.shape[0], X_test.shape[1], num_features))

print(f"Training data shape: {X_train.shape}")
print(f"Testing data shape: {X_test.shape}")

model = Sequential([
    LSTM(50, activation='relu', input_shape=(X_train.shape[1], X_train.shape[2])),
    Dense(1)
])

model.compile(optimizer='adam', loss='mse')
model.summary()

history = model.fit(X_train, y_train, epochs=30, batch_size=32, validation_data=(X_test, y_test), verbose=1)

plt.figure(figsize=(10,5))
plt.plot(history.history['loss'], label = 'Training Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.title("Model Loss During Training")
plt.xlabel("Epochs")
plt.ylabel("Loss")
plt.legend()
plt.show()

y_pred = model.predict(X_test)

y_test_rescaled = scaler.inverse_transform(np.hstack([np.zeros((y_test.shape[0], len(weather))), y_test.reshape(-1, 1)]))[:, -1]
y_pred_rescaled = scaler.inverse_transform(np.hstack([np.zeros((y_pred.shape[0], len(weather))), y_pred]))[:, -1]

plt.figure(figsize=(10, 5))
plt.plot(y_test_rescaled, label='Actual Temperatures')
plt.plot(y_pred_rescaled, label='Predicted Temperatures')
plt.title("Actual vs Predicted Temperatures")
plt.xlabel("Time Steps")
plt.ylabel("Temperature (째C)")
plt.legend()
plt.show()

def predict_future(model, recent_data, weather_data, steps, time_steps, num_features):
    future_predictions = []
    current_sequence = recent_data.copy()

    for step in range(steps):
        next_value = model.predict(current_sequence.reshape(1, time_steps, num_features), verbose=0)
        future_predictions.append(next_value.flatten()[0])
        if step < len(weather_data):
            next_weather_row = weather_data[step].reshape(1, -1)
        else:
            next_weather_row = np.zeros((1, num_features - 1))
        predicted_row = np.hstack([next_weather_row, next_value])
        current_sequence = np.append(current_sequence[1:], predicted_row.reshape(1, -1), axis=0)

    return np.array(future_predictions)

# Generate fake future data for prediction (based on previous data)
future_weather_data = np.random.rand(30, len(weather))
future_weather_data_scaled = scaler.transform(np.hstack([future_weather_data, np.zeros((future_weather_data.shape[0], 1))]))[:, :-1]

recent_data = X_test[-1]
future_steps = 30

future_predictions = predict_future(model, recent_data, future_weather_data_scaled, future_steps, time_steps, num_features)

future_predictions_rescaled = scaler.inverse_transform(
    np.hstack([np.zeros((future_predictions.shape[0], num_features - 1)), future_predictions.reshape(-1, 1)])
)[:, -1]

plt.figure(figsize=(10, 5))
plt.plot(range(len(y_test_rescaled)), y_test_rescaled, label="Past Temperatures")
plt.plot(range(len(y_test_rescaled), len(y_test_rescaled) + future_steps),future_predictions_rescaled,label="Future Predictions",linestyle='--')
plt.title("Temperature Prediction")
plt.xlabel("Time Steps")
plt.ylabel("Temperature (째C)")
plt.legend()
plt.show()

pip install keras-tuner --upgrade

import keras_tuner
import keras

def build_model(hp):
  model = keras.Sequential()
  model.add(keras.layers.Dense(
      hp.Choice('units', [8, 16, 32]),
      activation='relu'))
  model.add(keras.layers.Dense(1, activation='relu'))
  model.compile(loss='mse')
  return model

tuner = keras_tuner.RandomSearch(
    build_model,
    objective='val_loss',
    max_trials=5)

tuner.search(X_train, y_train, epochs=30, batch_size=32, validation_data=(X_test, y_test))
best_model = tuner.get_best_models()[0]

print(best_model.summary())

best_model.fit(X_train, y_train, epochs=30, batch_size=32, validation_data=(X_test, y_test))

plt.figure(figsize=(10,5))
plt.plot(history.history['loss'], label = 'Training Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.title("Model Loss During Training")
plt.xlabel("Epochs")
plt.ylabel("Loss")
plt.legend()
plt.show()

y_pred = best_model.predict(X_test)

y_test = y_test.reshape(-1, 1)
y_pred = y_pred.reshape(-1, 1)

plt.figure(figsize=(10, 5))
plt.plot(y_test_rescaled, label='Actual Temperatures', color='blue')
plt.plot(y_pred_rescaled, label='Predicted Temperatures', color='orange')
plt.title("Tuned Actual vs Predicted Temperatures")
plt.xlabel("Time Steps")
plt.ylabel("Temperature (째C)")
plt.legend()
plt.show()

def predict_future(best_model, recent_data, weather_data, steps, time_steps, num_features):
    future_predictions = []
    current_sequence = recent_data.copy()

    for step in range(steps):
        next_value = best_model.predict(current_sequence.reshape(1, time_steps, num_features), verbose=0)
        future_predictions.append(next_value.flatten()[0])
        if step < len(weather_data):
            next_weather_row = weather_data[step].reshape(1, -1)
        else:
            next_weather_row = np.zeros((1, num_features - 1))
        predicted_row = np.hstack([next_weather_row, next_value.reshape(1, -1)])
        current_sequence = np.append(current_sequence[1:], predicted_row.reshape(1, -1), axis=0)

    return np.array(future_predictions)

plt.figure(figsize=(10, 5))
plt.plot(range(len(y_test_rescaled)), y_test_rescaled, label="Past Temperatures")
plt.plot(range(len(y_test_rescaled), len(y_test_rescaled) + future_steps),future_predictions_rescaled,label="Future Predictions",linestyle='--')
plt.title("Tuned Temperature Prediction")
plt.xlabel("Time Steps")
plt.ylabel("Temperature (째C)")
plt.legend()
plt.show()